mapreduce.job.hdfs-servers**N/A**${fs.defaultFS}
mapreduce.job.committer.setup.cleanup.needed** true, if job needs job-setup and job-cleanup.                 false, otherwise   **true
mapreduce.task.io.sort.factor**The number of streams to merge at once while sorting   files.  This determines the number of open file handles.**10
mapreduce.task.io.sort.mb**The total amount of buffer memory to use while sorting   files, in megabytes.  By default, gives each merge stream 1MB, which   should minimize seeks.**100
mapreduce.map.sort.spill.percent**The soft limit in the serialization buffer. Once reached, a   thread will begin to spill the contents to disk in the background. Note that   collection will not block if this threshold is exceeded while a spill is   already in progress, so spills may be larger than this threshold when it is   set to less than .5**0.80
mapreduce.jobtracker.address**The host and port that the MapReduce job tracker runs   at.  If "local", then jobs are run in-process as a single map   and reduce task.   **local
mapreduce.local.clientfactory.class.name**This the client factory that is responsible for    creating local job runner client**org.apache.hadoop.mapred.LocalClientFactory
mapreduce.jobtracker.system.dir**The directory where MapReduce stores control files.   **${hadoop.tmp.dir}/mapred/system
mapreduce.jobtracker.staging.root.dir**The root of the staging area for users' job files   In practice, this should be the directory where users' home   directories are located (usually /user)   **${hadoop.tmp.dir}/mapred/staging
mapreduce.cluster.temp.dir**A shared directory for temporary files.   **${hadoop.tmp.dir}/mapred/temp
mapreduce.job.maps**The default number of map tasks per job.   Ignored when mapreduce.framework.name is "local".   **2
mapreduce.job.reduces**The default number of reduce tasks per job. Typically set to 99%   of the cluster's reduce capacity, so that if a node fails the reduces can   still be executed in a single wave.   Ignored when mapreduce.framework.name is "local".   **1
mapreduce.job.running.map.limit**The maximum number of simultaneous map tasks per job.   There is no limit if this value is 0 or negative.   **0
mapreduce.job.running.reduce.limit**The maximum number of simultaneous reduce tasks per job.   There is no limit if this value is 0 or negative.   **0
mapreduce.job.max.map**Limit on the number of map tasks allowed per job.   There is no limit if this value is negative.   **-1
mapreduce.job.reducer.preempt.delay.sec**The threshold (in seconds) after which an unsatisfied       mapper request triggers reducer preemption when there is no anticipated       headroom. If set to 0 or a negative value, the reducer is preempted as       soon as lack of headroom is detected. Default is 0.     **0
mapreduce.job.reducer.unconditional-preempt.delay.sec**The threshold (in seconds) after which an unsatisfied       mapper request triggers a forced reducer preemption irrespective of the       anticipated headroom. By default, it is set to 5 mins. Setting it to 0       leads to immediate reducer preemption. Setting to -1 disables this       preemption altogether.     **300
mapreduce.job.max.split.locations**The max number of block locations to store for each split for     locality calculation.     **10
mapreduce.job.split.metainfo.maxsize**The maximum permissible size of the split metainfo file.   The MapReduce ApplicationMaster won't attempt to read submitted split metainfo   files bigger than this configured value.   No limits if set to -1.   **10000000
mapreduce.map.maxattempts**Expert: The maximum number of attempts per map task.   In other words, framework will try to execute a map task these many number   of times before giving up on it.   **4
mapreduce.reduce.maxattempts**Expert: The maximum number of attempts per reduce task.   In other words, framework will try to execute a reduce task these many number   of times before giving up on it.   **4
mapreduce.reduce.shuffle.fetch.retry.enabled**Set to enable fetch retry during host restart.**${yarn.nodemanager.recovery.enabled}
mapreduce.reduce.shuffle.fetch.retry.interval-ms**Time of interval that fetcher retry to fetch again when some   non-fatal failure happens because of some events like NM restart.   **1000
mapreduce.reduce.shuffle.fetch.retry.timeout-ms**Timeout value for fetcher to retry to fetch again when some   non-fatal failure happens because of some events like NM restart.**30000
mapreduce.reduce.shuffle.retry-delay.max.ms**The maximum number of ms the reducer will delay before retrying   to download map data.   **60000
mapreduce.reduce.shuffle.parallelcopies**The default number of parallel transfers run by reduce   during the copy(shuffle) phase.   **5
mapreduce.reduce.shuffle.connect.timeout**Expert: The maximum amount of time (in milli seconds) reduce   task spends in trying to connect to a remote node for getting map output.   **180000
mapreduce.reduce.shuffle.read.timeout**Expert: The maximum amount of time (in milli seconds) reduce   task waits for map output data to be available for reading after obtaining   connection.   **180000
mapreduce.shuffle.listen.queue.size**The length of the shuffle server listen queue.**128
mapreduce.shuffle.connection-keep-alive.enable**set to true to support keep-alive connections.**false
mapreduce.shuffle.connection-keep-alive.timeout**The number of seconds a shuffle client attempts to retain    http connection. Refer "Keep-Alive: timeout=" header in    Http specification   **5
mapreduce.task.timeout**The number of milliseconds before a task will be   terminated if it neither reads an input, writes an output, nor   updates its status string.  A value of 0 disables the timeout.   **600000
mapreduce.map.memory.mb**The amount of memory to request from the scheduler for each   map task.   **1024
mapreduce.map.cpu.vcores**The number of virtual cores to request from the scheduler for   each map task.   **1
mapreduce.reduce.memory.mb**The amount of memory to request from the scheduler for each   reduce task.   **1024
mapreduce.reduce.cpu.vcores**The number of virtual cores to request from the scheduler for   each reduce task.   **1
mapred.child.java.opts**Java opts for the task processes.   The following symbol, if present, will be interpolated: @taskid@ is replaced   by current TaskID. Any other occurrences of '@' will go unchanged.   For example, to enable verbose gc logging to a file named for the taskid in   /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of:         -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc      Usage of -Djava.library.path can cause programs to no longer function if   hadoop native libraries are used. These values should instead be set as part   of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and   mapreduce.reduce.env config settings.   **-Xmx200m
mapred.child.env**User added environment variables for the task processes.   Example :   1) A=foo  This will set the env variable A to foo   2) B=$B:c This is inherit nodemanager's B env variable on Unix.   3) B=%B%;c This is inherit nodemanager's B env variable on Windows.   **N/A
mapreduce.admin.user.env**   Expert: Additional execution environment entries for   map and reduce task processes. This is not an additive property.   You must preserve the original value if you want your map and   reduce tasks to have access to native libraries (compression, etc).   When this value is empty, the command to set execution   envrionment will be OS dependent:   For linux, use LD_LIBRARY_PATH=$HADOOP_COMMON_HOME/lib/native.   For windows, use PATH = %PATH%;%HADOOP_COMMON_HOME%\\bin.   **N/A
yarn.app.mapreduce.am.log.level**The logging level for the MR ApplicationMaster. The allowed   levels are: OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.   The setting here could be overriden if "mapreduce.job.log4j-properties-file"   is set.   **INFO
mapreduce.map.log.level**The logging level for the map task. The allowed levels are:   OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.   The setting here could be overridden if "mapreduce.job.log4j-properties-file"   is set.   **INFO
mapreduce.reduce.log.level**The logging level for the reduce task. The allowed levels are:   OFF, FATAL, ERROR, WARN, INFO, DEBUG, TRACE and ALL.   The setting here could be overridden if "mapreduce.job.log4j-properties-file"   is set.   **INFO
mapreduce.reduce.merge.inmem.threshold**The threshold, in terms of the number of files   for the in-memory merge process. When we accumulate threshold number of files   we initiate the in-memory merge and spill to disk. A value of 0 or less than   0 indicates we want to DON'T have any threshold and instead depend only on   the ramfs's memory consumption to trigger the merge.   **1000
mapreduce.reduce.shuffle.merge.percent**The usage threshold at which an in-memory merge will be   initiated, expressed as a percentage of the total memory allocated to   storing in-memory map outputs, as defined by   mapreduce.reduce.shuffle.input.buffer.percent.   **0.66
mapreduce.reduce.shuffle.input.buffer.percent**The percentage of memory to be allocated from the maximum heap   size to storing map outputs during the shuffle.   **0.70
mapreduce.reduce.input.buffer.percent**The percentage of memory- relative to the maximum heap size- to   retain map outputs during the reduce. When the shuffle is concluded, any   remaining map outputs in memory must consume less than this threshold before   the reduce can begin.   **0.0
mapreduce.reduce.shuffle.memory.limit.percent**Expert: Maximum percentage of the in-memory limit that a   single shuffle can consume. Range of valid values is [0.0, 1.0]. If the value   is 0.0 map outputs are shuffled directly to disk.**0.25
mapreduce.shuffle.ssl.enabled**     Whether to use SSL for for the Shuffle HTTP endpoints.   **false
mapreduce.shuffle.ssl.file.buffer.size**Buffer size for reading spills from file when using SSL.   **65536
mapreduce.shuffle.max.connections**Max allowed connections for the shuffle.  Set to 0 (zero)                to indicate no limit on the number of connections.   **0
mapreduce.shuffle.max.threads**Max allowed threads for serving shuffle connections. Set to zero   to indicate the default of 2 times the number of available   processors (as reported by Runtime.availableProcessors()). Netty is used to   serve requests, so a thread is not needed for each connection.   **0
mapreduce.shuffle.transferTo.allowed**This option can enable/disable using nio transferTo method in   the shuffle phase. NIO transferTo does not perform well on windows in the   shuffle phase. Thus, with this configuration property it is possible to   disable it, in which case custom transfer method will be used. Recommended   value is false when running Hadoop on Windows. For Linux, it is recommended   to set it to true. If nothing is set then the default value is false for   Windows, and true for Linux.   **N/A
mapreduce.shuffle.transfer.buffer.size**This property is used only if   mapreduce.shuffle.transferTo.allowed is set to false. In that case,   this property defines the size of the buffer used in the buffer copy code   for the shuffle phase. The size of this buffer determines the size of the IO   requests.   **131072
mapreduce.reduce.markreset.buffer.percent**The percentage of memory -relative to the maximum heap size- to   be used for caching values when using the mark-reset functionality.   **0.0
mapreduce.map.speculative**If true, then multiple instances of some map tasks                may be executed in parallel.**true
mapreduce.reduce.speculative**If true, then multiple instances of some reduce tasks                may be executed in parallel.**true
mapreduce.job.speculative.speculative-cap-running-tasks**The max percent (0-1) of running tasks that   can be speculatively re-executed at any time.**0.1
mapreduce.job.speculative.speculative-cap-total-tasks**The max percent (0-1) of all tasks that   can be speculatively re-executed at any time.**0.01
mapreduce.job.speculative.minimum-allowed-tasks**The minimum allowed tasks that   can be speculatively re-executed at any time.**10
mapreduce.job.speculative.retry-after-no-speculate**The waiting time(ms) to do next round of speculation   if there is no task speculated in this round.**1000
mapreduce.job.speculative.retry-after-speculate**The waiting time(ms) to do next round of speculation   if there are tasks speculated in this round.**15000
mapreduce.job.map.output.collector.class**     The MapOutputCollector implementation(s) to use. This may be a comma-separated     list of class names, in which case the map task will try to initialize each     of the collectors in turn. The first to successfully initialize will be used.   **org.apache.hadoop.mapred.MapTask$MapOutputBuffer
mapreduce.job.speculative.slowtaskthreshold**The number of standard deviations by which a task's   ave progress-rates must be lower than the average of all running tasks'   for the task to be considered too slow.   **1.0
mapreduce.job.ubertask.enable**Whether to enable the small-jobs "ubertask" optimization,   which runs "sufficiently small" jobs sequentially within a single JVM.   "Small" is defined by the following maxmaps, maxreduces, and maxbytes   settings. Note that configurations for application masters also affect   the "Small" definition - yarn.app.mapreduce.am.resource.mb must be   larger than both mapreduce.map.memory.mb and mapreduce.reduce.memory.mb,   and yarn.app.mapreduce.am.resource.cpu-vcores must be larger than   both mapreduce.map.cpu.vcores and mapreduce.reduce.cpu.vcores to enable   ubertask. Users may override this value.   **false
mapreduce.job.ubertask.maxmaps**Threshold for number of maps, beyond which job is considered   too big for the ubertasking optimization.  Users may override this value,   but only downward.   **9
mapreduce.job.ubertask.maxreduces**Threshold for number of reduces, beyond which job is considered   too big for the ubertasking optimization.  CURRENTLY THE CODE CANNOT SUPPORT   MORE THAN ONE REDUCE and will ignore larger values.  (Zero is a valid max,   however.)  Users may override this value, but only downward.   **1
mapreduce.job.ubertask.maxbytes**Threshold for number of input bytes, beyond which job is   considered too big for the ubertasking optimization.  If no value is   specified, dfs.block.size is used as a default.  Be sure to specify a   default value in mapred-site.xml if the underlying filesystem is not HDFS.   Users may override this value, but only downward.   **N/A
mapreduce.job.emit-timeline-data**Specifies if the Application Master should emit timeline data     to the timeline server. Individual jobs can override this value.     **false
mapreduce.job.sharedcache.mode**     A comma delimited list of resource categories to submit to the shared cache.     The valid categories are: jobjar, libjars, files, archives.     If "disabled" is specified then the job submission code will not use     the shared cache.   **disabled
mapreduce.input.fileinputformat.split.minsize**The minimum size chunk that map input should be split   into.  Note that some file formats may have minimum split sizes that   take priority over this setting.**0
mapreduce.input.fileinputformat.list-status.num-threads**The number of threads to use to list and fetch block locations   for the specified input paths. Note: multiple threads should not be used   if a custom non thread-safe path filter is used.   **1
mapreduce.input.lineinputformat.linespermap**When using NLineInputFormat, the number of lines of input data   to include in each split.**1
mapreduce.client.submit.file.replication**The replication level for submitted job files.  This   should be around the square root of the number of nodes.   **10
mapreduce.task.files.preserve.failedtasks**Should the files for failed tasks be kept. This should only be                used on jobs that are failing, because the storage is never                reclaimed. It also prevents the map outputs from being erased                from the reduce directory as they are consumed.**false
mapreduce.output.fileoutputformat.compress**Should the job outputs be compressed?   **false
mapreduce.output.fileoutputformat.compress.type**If the job outputs are to compressed as SequenceFiles, how should                they be compressed? Should be one of NONE, RECORD or BLOCK.   **RECORD
mapreduce.output.fileoutputformat.compress.codec**If the job outputs are compressed, how should they be compressed?   **org.apache.hadoop.io.compress.DefaultCodec
mapreduce.map.output.compress**Should the outputs of the maps be compressed before being                sent across the network. Uses SequenceFile compression.   **false
mapreduce.map.output.compress.codec**If the map outputs are compressed, how should they be                compressed?   **org.apache.hadoop.io.compress.DefaultCodec
map.sort.class**The default sort class for sorting keys.   **org.apache.hadoop.util.QuickSort
mapreduce.task.userlog.limit.kb**The maximum size of user-logs of each task in KB. 0 disables the cap.   **0
yarn.app.mapreduce.am.container.log.limit.kb**The maximum size of the MRAppMaster attempt container logs in KB.     0 disables the cap.   **0
yarn.app.mapreduce.task.container.log.backups**Number of backup files for task logs when using     ContainerRollingLogAppender (CRLA). See     org.apache.log4j.RollingFileAppender.maxBackupIndex. By default,     ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA     is enabled for tasks when both mapreduce.task.userlog.limit.kb and     yarn.app.mapreduce.task.container.log.backups are greater than zero.   **0
yarn.app.mapreduce.am.container.log.backups**Number of backup files for the ApplicationMaster logs when using     ContainerRollingLogAppender (CRLA). See     org.apache.log4j.RollingFileAppender.maxBackupIndex. By default,     ContainerLogAppender (CLA) is used, and container logs are not rolled. CRLA     is enabled for the ApplicationMaster when both     yarn.app.mapreduce.am.container.log.limit.kb and     yarn.app.mapreduce.am.container.log.backups are greater than zero.   **0
yarn.app.mapreduce.shuffle.log.separate**If enabled ('true') logging generated by the client-side shuffle     classes in a reducer will be written in a dedicated log file     'syslog.shuffle' instead of 'syslog'.   **true
yarn.app.mapreduce.shuffle.log.limit.kb**Maximum size of the syslog.shuffle file in kilobytes     (0 for no limit).   **0
yarn.app.mapreduce.shuffle.log.backups**If yarn.app.mapreduce.shuffle.log.limit.kb and     yarn.app.mapreduce.shuffle.log.backups are greater than zero     then a ContainerRollngLogAppender is used instead of ContainerLogAppender     for syslog.shuffle. See     org.apache.log4j.RollingFileAppender.maxBackupIndex   **0
mapreduce.job.maxtaskfailures.per.tracker**The number of task-failures on a node manager of a given job                after which new tasks of that job aren't assigned to it. It                MUST be less than mapreduce.map.maxattempts and                mapreduce.reduce.maxattempts otherwise the failed task will                never be tried on a different node.   **3
mapreduce.client.output.filter**The filter for controlling the output of the task's userlogs sent                to the console of the JobClient.                The permissible options are: NONE, KILLED, FAILED, SUCCEEDED and                ALL.   **FAILED
mapreduce.client.completion.pollinterval**The interval (in milliseconds) between which the JobClient     polls the MapReduce ApplicationMaster for updates about job status. You may want to     set this to a lower value to make tests run faster on a single node system. Adjusting     this value in production may lead to unwanted client-server traffic.     **5000
mapreduce.client.progressmonitor.pollinterval**The interval (in milliseconds) between which the JobClient     reports status to the console and checks for job completion. You may want to set this     to a lower value to make tests run faster on a single node system. Adjusting     this value in production may lead to unwanted client-server traffic.     **1000
mapreduce.client.libjars.wildcard**         Whether the libjars cache files should be localized using         a wildcarded directory instead of naming each archive independently.         Using wildcards reduces the space needed for storing the job         information in the case of a highly available resource manager         configuration.         This propery should only be set to false for specific         jobs which are highly sensitive to the details of the archive         localization.  Having this property set to true will cause the archives         to all be localized to the same local cache location.  If false, each         archive will be localized to its own local cache location.  In both         cases a symbolic link will be created to every archive from the job's         working directory.     **true
mapreduce.task.profile**To set whether the system should collect profiler      information for some of the tasks in this job? The information is stored      in the user log directory. The value is "true" if task profiling      is enabled.**false
mapreduce.task.profile.maps** To set the ranges of map tasks to profile.     mapreduce.task.profile has to be set to true for the value to be accounted.     **0-2
mapreduce.task.profile.reduces** To set the ranges of reduce tasks to profile.     mapreduce.task.profile has to be set to true for the value to be accounted.     **0-2
mapreduce.task.profile.params**JVM profiler parameters used to profile map and reduce task       attempts. This string may contain a single format specifier %s that will       be replaced by the path to profile.out in the task attempt log directory.       To specify different profiling options for map tasks and reduce tasks,       more specific parameters mapreduce.task.profile.map.params and       mapreduce.task.profile.reduce.params should be used.**-agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s
mapreduce.task.profile.map.params**Map-task-specific JVM profiler parameters. See       mapreduce.task.profile.params**${mapreduce.task.profile.params}
mapreduce.task.profile.reduce.params**Reduce-task-specific JVM profiler parameters. See       mapreduce.task.profile.params**${mapreduce.task.profile.params}
mapreduce.task.skip.start.attempts** The number of Task attempts AFTER which skip mode      will be kicked off. When skip mode is kicked off, the     tasks reports the range of records which it will process      next, to the MR ApplicationMaster. So that on failures, the MR AM     knows which ones are possibly the bad records. On further executions,     those are skipped.     **2
mapreduce.map.skip.proc-count.auto-incr** The flag which if set to true,      SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS is incremented      by MapRunner after invoking the map function. This value must be set to      false for applications which process the records asynchronously      or buffer the input records. For example streaming.      In such cases applications should increment this counter on their own.     **true
mapreduce.reduce.skip.proc-count.auto-incr** The flag which if set to true,      SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS is incremented      by framework after invoking the reduce function. This value must be set to      false for applications which process the records asynchronously      or buffer the input records. For example streaming.      In such cases applications should increment this counter on their own.     **true
mapreduce.job.skip.outdir** If no value is specified here, the skipped records are     written to the output directory at _logs/skip.     User can stop writing skipped records by giving the value "none".     **N/A
mapreduce.map.skip.maxrecords** The number of acceptable skip records surrounding the bad     record PER bad record in mapper. The number includes the bad record as well.     To turn the feature of detection/skipping of bad records off, set the     value to 0.     The framework tries to narrow down the skipped range by retrying     until this threshold is met OR all attempts get exhausted for this task.     Set the value to Long.MAX_VALUE to indicate that framework need not try to     narrow down. Whatever records(depends on application) get skipped are     acceptable.     **0
mapreduce.reduce.skip.maxgroups** The number of acceptable skip groups surrounding the bad     group PER bad group in reducer. The number includes the bad group as well.     To turn the feature of detection/skipping of bad groups off, set the     value to 0.     The framework tries to narrow down the skipped range by retrying     until this threshold is met OR all attempts get exhausted for this task.     Set the value to Long.MAX_VALUE to indicate that framework need not try to     narrow down. Whatever groups(depends on application) get skipped are     acceptable.     **0
mapreduce.ifile.readahead**Configuration key to enable/disable IFile readahead.     **true
mapreduce.ifile.readahead.bytes**Configuration key to set the IFile readahead length in bytes.     **4194304
mapreduce.job.queuename** Queue to which a job is submitted. This must match one of the     queues defined in mapred-queues.xml for the system. Also, the ACL setup     for the queue must allow the current user to submit a job to the queue.     Before specifying a queue, ensure that the system is configured with     the queue, and access is allowed for submitting jobs to the queue.   **default
mapreduce.job.tags** Tags for the job that will be passed to YARN at submission       time. Queries to YARN for applications can filter on these tags.     **N/A
mapreduce.cluster.local.dir**       The local directory where MapReduce stores intermediate       data files.  May be a comma-separated list of       directories on different devices in order to spread disk i/o.       Directories that do not exist are ignored.   **${hadoop.tmp.dir}/mapred/local
mapreduce.cluster.acls.enabled** Specifies whether ACLs should be checked     for authorization of users for doing various queue and job level operations.     ACLs are disabled by default. If enabled, access control checks are made by     MapReduce ApplicationMaster when requests are made by users for queue     operations like submit job to a queue and kill a job in the queue and job     operations like viewing the job-details (See mapreduce.job.acl-view-job)     or for modifying the job (See mapreduce.job.acl-modify-job) using     Map/Reduce APIs, RPCs or via the console and web user interfaces.     For enabling this flag, set to true in mapred-site.xml file of all     MapReduce clients (MR job submitting nodes).   **false
mapreduce.job.acl-modify-job** Job specific access-control list for 'modifying' the job. It     is only used if authorization is enabled in Map/Reduce by setting the     configuration property mapreduce.cluster.acls.enabled to true.     This specifies the list of users and/or groups who can do modification     operations on the job. For specifying a list of users and groups the     format to use is "user1,user2 group1,group". If set to '*', it allows all     users/groups to modify this job. If set to ' '(i.e. space), it allows     none. This configuration is used to guard all the modifications with respect     to this job and takes care of all the following operations:       o killing this job       o killing a task of this job, failing a task of this job       o setting the priority of this job     Each of these operations are also protected by the per-queue level ACL     "acl-administer-jobs" configured via mapred-queues.xml. So a caller should     have the authorization to satisfy either the queue-level ACL or the     job-level ACL.      Irrespective of this ACL configuration, (a) job-owner, (b) the user who     started the cluster, (c) members of an admin configured supergroup     configured via mapreduce.cluster.permissions.supergroup and (d) queue     administrators of the queue to which this job was submitted to configured     via acl-administer-jobs for the specific queue in mapred-queues.xml can     do all the modification operations on a job.      By default, nobody else besides job-owner, the user who started the cluster,     members of supergroup and queue administrators can perform modification     operations on a job.   ** 
mapreduce.job.acl-view-job** Job specific access-control list for 'viewing' the job. It is     only used if authorization is enabled in Map/Reduce by setting the     configuration property mapreduce.cluster.acls.enabled to true.     This specifies the list of users and/or groups who can view private details     about the job. For specifying a list of users and groups the     format to use is "user1,user2 group1,group". If set to '*', it allows all     users/groups to modify this job. If set to ' '(i.e. space), it allows     none. This configuration is used to guard some of the job-views and at     present only protects APIs that can return possibly sensitive information     of the job-owner like       o job-level counters       o task-level counters       o tasks' diagnostic information       o task-logs displayed on the HistoryServer's web-UI and       o job.xml showed by the HistoryServer's web-UI     Every other piece of information of jobs is still accessible by any other     user, for e.g., JobStatus, JobProfile, list of jobs in the queue, etc.      Irrespective of this ACL configuration, (a) job-owner, (b) the user who     started the cluster, (c) members of an admin configured supergroup     configured via mapreduce.cluster.permissions.supergroup and (d) queue     administrators of the queue to which this job was submitted to configured     via acl-administer-jobs for the specific queue in mapred-queues.xml can     do all the view operations on a job.      By default, nobody else besides job-owner, the user who started the     cluster, memebers of supergroup and queue administrators can perform     view operations on a job.   ** 
mapreduce.job.finish-when-all-reducers-done**Specifies whether the job should complete once all reducers      have finished, regardless of whether there are still running mappers.   **false
mapreduce.job.token.tracking.ids.enabled**Whether to write tracking ids of tokens to     job-conf. When true, the configuration property     "mapreduce.job.token.tracking.ids" is set to the token-tracking-ids of     the job**false
mapreduce.job.token.tracking.ids**When mapreduce.job.token.tracking.ids.enabled is     set to true, this is set by the framework to the     token-tracking-ids used by the job.**N/A
mapreduce.task.merge.progress.records** The number of records to process during merge before    sending a progress notification to the MR ApplicationMaster.   **10000
mapreduce.task.combine.progress.records** The number of records to process during combine output collection    before sending a progress notification.   **10000
mapreduce.job.reduce.slowstart.completedmaps**Fraction of the number of maps in the job which should be   complete before reduces are scheduled for the job.   **0.05
mapreduce.job.complete.cancel.delegation.tokens** if false - do not unregister/cancel delegation tokens from     renewal, because same tokens may be used by spawned jobs   **true
mapreduce.shuffle.port**Default port that the ShuffleHandler will run on. ShuffleHandler    is a service run at the NodeManager to facilitate transfers of intermediate    Map outputs to requesting Reducers.   **13562
mapreduce.job.reduce.shuffle.consumer.plugin.class**   Name of the class whose instance will be used   to send shuffle requests by reducetasks of this job.   The class must be an instance of org.apache.hadoop.mapred.ShuffleConsumerPlugin.   **org.apache.hadoop.mapreduce.task.reduce.Shuffle
mapreduce.job.node-label-expression**All the containers of the Map Reduce job will be run with this   node label expression. If the node-label-expression for job is not set, then   it will use queue's default-node-label-expression for all job's containers.   **N/A
mapreduce.job.am.node-label-expression**This is node-label configuration for Map Reduce Application Master   container. If not configured it will make use of   mapreduce.job.node-label-expression and if job's node-label expression is not   configured then it will use queue's default-node-label-expression.   **N/A
mapreduce.map.node-label-expression**This is node-label configuration for Map task containers. If not   configured it will use mapreduce.job.node-label-expression and if job's   node-label expression is not configured then it will use queue's   default-node-label-expression.   **N/A
mapreduce.reduce.node-label-expression**This is node-label configuration for Reduce task containers. If   not configured it will use mapreduce.job.node-label-expression and if job's   node-label expression is not configured then it will use queue's   default-node-label-expression.   **N/A
mapreduce.job.counters.limit**Limit on the number of user counters allowed per job.   **120
mapreduce.framework.name**The runtime framework for executing MapReduce jobs.   Can be one of local, classic or yarn.   **local
yarn.app.mapreduce.am.staging-dir**The staging dir used while submitting jobs.   **/tmp/hadoop-yarn/staging
mapreduce.am.max-attempts**The maximum number of application attempts. It is a   application-specific setting. It should not be larger than the global number   set by resourcemanager. Otherwise, it will be override. The default number is   set to 2, to allow at least one retry for AM.**2
mapreduce.job.end-notification.url**Indicates url which will be called on completion of job to inform               end status of job.               User can give at most 2 variables with URI : $jobId and $jobStatus.               If they are present in URI, then they will be replaced by their               respective values. **N/A
mapreduce.job.end-notification.retry.attempts**The number of times the submitter of the job wants to retry job     end notification if it fails. This is capped by     mapreduce.job.end-notification.max.attempts**0
mapreduce.job.end-notification.retry.interval**The number of milliseconds the submitter of the job wants to     wait before job end notification is retried if it fails. This is capped by     mapreduce.job.end-notification.max.retry.interval**1000
mapreduce.job.end-notification.max.attempts**The maximum number of times a URL will be read for providing job     end notification. Cluster administrators can set this to limit how long     after end of a job, the Application Master waits before exiting. Must be     marked as final to prevent users from overriding this.   **5
mapreduce.job.log4j-properties-file**Used to override the default settings of log4j in container-log4j.properties     for NodeManager. Like container-log4j.properties, it requires certain     framework appenders properly defined in this overriden file. The file on the     path will be added to distributed cache and classpath. If no-scheme is given     in the path, it defaults to point to a log4j file on the local FS.     **N/A
mapreduce.job.end-notification.max.retry.interval**The maximum amount of time (in milliseconds) to wait before      retrying job end notification. Cluster administrators can set this to      limit how long the Application Master waits before exiting. Must be marked      as final to prevent users from overriding this.**5000
yarn.app.mapreduce.am.env**User added environment variables for the MR App Master   processes. Example :   1) A=foo  This will set the env variable A to foo   2) B=$B:c This is inherit tasktracker's B env variable.   **N/A
yarn.app.mapreduce.am.admin.user.env** Environment variables for the MR App Master   processes for admin purposes. These values are set first and can be   overridden by the user env (yarn.app.mapreduce.am.env) Example :   1) A=foo  This will set the env variable A to foo   2) B=$B:c This is inherit app master's B env variable.   **N/A
yarn.app.mapreduce.am.command-opts**Java opts for the MR App Master processes.   The following symbol, if present, will be interpolated: @taskid@ is replaced   by current TaskID. Any other occurrences of '@' will go unchanged.   For example, to enable verbose gc logging to a file named for the taskid in   /tmp and to set the heap maximum to be a gigabyte, pass a 'value' of:         -Xmx1024m -verbose:gc -Xloggc:/tmp/@taskid@.gc    Usage of -Djava.library.path can cause programs to no longer function if   hadoop native libraries are used. These values should instead be set as part   of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and   mapreduce.reduce.env config settings.   **-Xmx1024m
yarn.app.mapreduce.am.admin-command-opts**Java opts for the MR App Master processes for admin purposes.   It will appears before the opts set by yarn.app.mapreduce.am.command-opts and   thus its options can be overridden user.    Usage of -Djava.library.path can cause programs to no longer function if   hadoop native libraries are used. These values should instead be set as part   of LD_LIBRARY_PATH in the map / reduce JVM env using the mapreduce.map.env and   mapreduce.reduce.env config settings.   **N/A
yarn.app.mapreduce.am.job.task.listener.thread-count**The number of threads used to handle RPC calls in the     MR AppMaster from remote tasks**30
yarn.app.mapreduce.am.job.client.port-range**Range of ports that the MapReduce AM can use when binding.     Leave blank if you want all possible ports.     For example 50000-50050,50100-50200**N/A
yarn.app.mapreduce.am.webapp.port-range**Range of ports that the MapReduce AM can use for its webapp when binding.     Leave blank if you want all possible ports.     For example 50000-50050,50100-50200**N/A
yarn.app.mapreduce.am.job.committer.cancel-timeout**The amount of time in milliseconds to wait for the output     committer to cancel an operation if the job is killed**60000
yarn.app.mapreduce.am.job.committer.commit-window**Defines a time window in milliseconds for output commit   operations.  If contact with the RM has occurred within this window then   commits are allowed, otherwise the AM will not allow output commits until   contact with the RM has been re-established.**10000
mapreduce.fileoutputcommitter.algorithm.version**The file output committer algorithm version   valid algorithm version number: 1 or 2   default to 1, which is the original algorithm    In algorithm version 1,    1. commitTask will rename directory   $joboutput/_temporary/$appAttemptID/_temporary/$taskAttemptID/   to   $joboutput/_temporary/$appAttemptID/$taskID/    2. recoverTask will also do a rename   $joboutput/_temporary/$appAttemptID/$taskID/   to   $joboutput/_temporary/($appAttemptID + 1)/$taskID/    3. commitJob will merge every task output file in   $joboutput/_temporary/$appAttemptID/$taskID/   to   $joboutput/, then it will delete $joboutput/_temporary/   and write $joboutput/_SUCCESS    It has a performance regression, which is discussed in MAPREDUCE-4815.   If a job generates many files to commit then the commitJob   method call at the end of the job can take minutes.   the commit is single-threaded and waits until all   tasks have completed before commencing.    algorithm version 2 will change the behavior of commitTask,   recoverTask, and commitJob.    1. commitTask will rename all files in   $joboutput/_temporary/$appAttemptID/_temporary/$taskAttemptID/   to $joboutput/    2. recoverTask actually doesn't require to do anything, but for   upgrade from version 1 to version 2 case, it will check if there   are any files in   $joboutput/_temporary/($appAttemptID - 1)/$taskID/   and rename them to $joboutput/    3. commitJob can simply delete $joboutput/_temporary and write   $joboutput/_SUCCESS    This algorithm will reduce the output commit time for   large jobs by having the tasks commit directly to the final   output directory as they were completing and commitJob had   very little to do.   **1
yarn.app.mapreduce.am.scheduler.heartbeat.interval-ms**The interval in ms at which the MR AppMaster should send     heartbeats to the ResourceManager**1000
yarn.app.mapreduce.client-am.ipc.max-retries**The number of client retries to the AM - before reconnecting     to the RM to fetch Application Status.**3
yarn.app.mapreduce.client-am.ipc.max-retries-on-timeouts**The number of client retries on socket timeouts to the AM - before     reconnecting to the RM to fetch Application Status.**3
yarn.app.mapreduce.client.max-retries**The number of client retries to the RM/HS before     throwing exception. This is a layer above the ipc.**3
yarn.app.mapreduce.am.resource.mb**The amount of memory the MR AppMaster needs.**1536
yarn.app.mapreduce.am.resource.cpu-vcores**       The number of virtual CPU cores the MR AppMaster needs.   **1
yarn.app.mapreduce.am.hard-kill-timeout-ms**      Number of milliseconds to wait before the job client kills the application.   **10000
yarn.app.mapreduce.client.job.max-retries**The number of retries the client will make for getJob and     dependent calls.     This is needed for non-HDFS DFS where additional, high level     retries are required to avoid spurious failures during the getJob call.     30 is a good value for WASB**3
yarn.app.mapreduce.client.job.retry-interval**The delay between getJob retries in ms for retries configured   with yarn.app.mapreduce.client.job.max-retries.**2000
mapreduce.application.classpath**CLASSPATH for MR applications. A comma-separated list   of CLASSPATH entries. If mapreduce.application.framework is set then this   must specify the appropriate classpath for that archive, and the name of   the archive must be present in the classpath.   If mapreduce.app-submission.cross-platform is false, platform-specific   environment vairable expansion syntax would be used to construct the default   CLASSPATH entries.   For Linux:   $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*,   $HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*.   For Windows:   %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/*,   %HADOOP_MAPRED_HOME%/share/hadoop/mapreduce/lib/*.    If mapreduce.app-submission.cross-platform is true, platform-agnostic default   CLASSPATH for MR applications would be used:   {{HADOOP_MAPRED_HOME}}/share/hadoop/mapreduce/*,   {{HADOOP_MAPRED_HOME}}/share/hadoop/mapreduce/lib/*   Parameter expansion marker will be replaced by NodeManager on container   launch based on the underlying OS accordingly.   **N/A
mapreduce.app-submission.cross-platform**If enabled, user can submit an application cross-platform   i.e. submit an application from a Windows client to a Linux/Unix server or   vice versa.   **false
mapreduce.application.framework.path**Path to the MapReduce framework archive. If set, the framework     archive will automatically be distributed along with the job, and this     path would normally reside in a public location in an HDFS filesystem. As     with distributed cache files, this can be a URL with a fragment specifying     the alias to use for the archive name. For example,     hdfs:/mapred/framework/hadoop-mapreduce-2.1.1.tar.gz#mrframework would     alias the localized archive as "mrframework".      Note that mapreduce.application.classpath must include the appropriate     classpath for the specified framework. The base name of the archive, or     alias of the archive if an alias is used, must appear in the specified     classpath.   **N/A
mapreduce.job.classloader**Whether to use a separate (isolated) classloader for     user classes in the task JVM.**false
mapreduce.job.classloader.system.classes**Used to override the default definition of the system classes for     the job classloader. The system classes are a comma-separated list of     patterns that indicate whether to load a class from the system classpath,     instead from the user-supplied JARs, when mapreduce.job.classloader is     enabled.      A positive pattern is defined as:         1. A single class name 'C' that matches 'C' and transitively all nested             classes 'C$*' defined in C;         2. A package name ending with a '.' (e.g., "com.example.") that matches             all classes from that package.     A negative pattern is defined by a '-' in front of a positive pattern     (e.g., "-com.example.").      A class is considered a system class if and only if it matches one of the     positive patterns and none of the negative ones. More formally:     A class is a member of the inclusion set I if it matches one of the positive     patterns. A class is a member of the exclusion set E if it matches one of     the negative patterns. The set of system classes S = I \ E.   **N/A
mapreduce.jvm.system-properties-to-log**Comma-delimited list of system properties to log on mapreduce JVM start**os.name,os.version,java.home,java.runtime.version,java.vendor,java.version,java.vm.name,java.class.path,java.io.tmpdir,user.dir,user.name
mapreduce.jobhistory.address**MapReduce JobHistory Server IPC host:port**0.0.0.0:10020
mapreduce.jobhistory.webapp.address**MapReduce JobHistory Server Web UI host:port**0.0.0.0:19888
mapreduce.jobhistory.webapp.https.address**     The https address the MapReduce JobHistory Server WebApp is on.   **0.0.0.0:19890
mapreduce.jobhistory.keytab**     Location of the kerberos keytab file for the MapReduce     JobHistory Server.   **/etc/security/keytab/jhs.service.keytab
mapreduce.jobhistory.principal**     Kerberos principal name for the MapReduce JobHistory Server.   **jhs/_HOST@REALM.TLD
mapreduce.jobhistory.intermediate-done-dir**N/A**${yarn.app.mapreduce.am.staging-dir}/history/done_intermediate
mapreduce.jobhistory.done-dir**N/A**${yarn.app.mapreduce.am.staging-dir}/history/done
mapreduce.jobhistory.cleaner.enable**N/A**true
mapreduce.jobhistory.cleaner.interval-ms** How often the job history cleaner checks for files to delete,   in milliseconds. Defaults to 86400000 (one day). Files are only deleted if   they are older than mapreduce.jobhistory.max-age-ms.   **86400000
mapreduce.jobhistory.max-age-ms** Job history files older than this many milliseconds will   be deleted when the history cleaner runs. Defaults to 604800000 (1 week).   **604800000
mapreduce.jobhistory.client.thread-count**The number of threads to handle client API requests**10
mapreduce.jobhistory.datestring.cache.size**Size of the date string cache. Effects the number of directories   which will be scanned to find a job.**200000
mapreduce.jobhistory.joblist.cache.size**Size of the job list cache**20000
mapreduce.jobhistory.loadedjobs.cache.size**Size of the loaded job cache.  This property is ignored if   the property mapreduce.jobhistory.loadedtasks.cache.size is set to a   positive value.   **5
mapreduce.jobhistory.loadedtasks.cache.size**Change the job history cache limit to be set in terms   of total task count.  If the total number of tasks loaded exceeds   this value, then the job cache will be shrunk down until it is   under this limit (minimum 1 job in cache).  If this value is empty   or nonpositive then the cache reverts to using the property   mapreduce.jobhistory.loadedjobs.cache.size as a job cache size.    Two recommendations for the mapreduce.jobhistory.loadedtasks.cache.size   property:   1) For every 100k of cache size, set the heap size of the Job History      Server to 1.2GB. For example,      mapreduce.jobhistory.loadedtasks.cache.size=500000, heap size=6GB.   2) Make sure that the cache size is larger than the number of tasks      required for the largest job run on the cluster. It might be a good      idea to set the value slightly higher (say, 20%) in order to allow      for job size growth.   **N/A
mapreduce.jobhistory.move.interval-ms**Scan for history files to more from intermediate done dir to done   dir at this frequency.   **180000
mapreduce.jobhistory.move.thread-count**The number of threads used to move files.**3
mapreduce.jobhistory.store.class**The HistoryStorage class to use to cache history data.**N/A
mapreduce.jobhistory.minicluster.fixed.ports**Whether to use fixed ports with the minicluster**false
mapreduce.jobhistory.admin.address**The address of the History server admin interface.**0.0.0.0:10033
mapreduce.jobhistory.admin.acl**ACL of who can be admin of the History server.***
mapreduce.jobhistory.recovery.enable**Enable the history server to store server state and recover   server state upon startup.  If enabled then   mapreduce.jobhistory.recovery.store.class must be specified.**false
mapreduce.jobhistory.recovery.store.class**The HistoryServerStateStoreService class to store history server   state for recovery.**org.apache.hadoop.mapreduce.v2.hs.HistoryServerFileSystemStateStoreService
mapreduce.jobhistory.recovery.store.fs.uri**The URI where history server state will be stored if   HistoryServerFileSystemStateStoreService is configured as the recovery   storage class.**${hadoop.tmp.dir}/mapred/history/recoverystore
mapreduce.jobhistory.recovery.store.leveldb.path**The URI where history server state will be stored if   HistoryServerLeveldbSystemStateStoreService is configured as the recovery   storage class.**${hadoop.tmp.dir}/mapred/history/recoverystore
mapreduce.jobhistory.http.policy**     This configures the HTTP endpoint for JobHistoryServer web UI.     The following values are supported:     - HTTP_ONLY : Service is provided only on http     - HTTPS_ONLY : Service is provided only on https   **HTTP_ONLY
mapreduce.jobhistory.jobname.limit**      Number of characters allowed for job name in Job History Server web page.   **50
mapreduce.jobhistory.jhist.format**   File format the AM will use when generating the .jhist file.  Valid   values are "json" for text output and "binary" for faster parsing.   **json
yarn.app.mapreduce.am.containerlauncher.threadpool-initial-size**The initial size of thread pool to launch containers in the     app master.   **10
mapreduce.task.exit.timeout**The number of milliseconds before a task will be   terminated if it stays in finishing state for too long.   After a task attempt completes from TaskUmbilicalProtocol's point of view,   it will be transitioned to finishing state. That will give a chance for the   task to exit by itself.   **60000
mapreduce.task.exit.timeout.check-interval-ms**The interval in milliseconds between which the MR framework   checks if task attempts stay in finishing state for too long.   **20000
mapreduce.task.local-fs.write-limit.bytes**Limit on the byte written to the local file system by each task.   This limit only applies to writes that go through the Hadoop filesystem APIs   within the task process (i.e.: writes that will update the local filesystem's   BYTES_WRITTEN counter). It does not cover other writes such as logging,   sideband writes from subprocesses (e.g.: streaming jobs), etc.   Negative values disable the limit.   default is -1**-1
mapreduce.jobhistory.webapp.rest-csrf.enabled**     Enable the CSRF filter for the job history web app   **false
mapreduce.jobhistory.webapp.rest-csrf.custom-header**     Optional parameter that indicates the custom header name to use for CSRF     protection.   **X-XSRF-Header
mapreduce.jobhistory.webapp.rest-csrf.methods-to-ignore**     Optional parameter that indicates the list of HTTP methods that do not     require CSRF protection   **GET,OPTIONS,HEAD
mapreduce.job.cache.limit.max-resources**The maximum number of resources a map reduce job is allowed to     submit for localization via files, libjars, archives, and jobjar command     line arguments and through the distributed cache. If set to 0 the limit is     ignored.   **0
mapreduce.job.cache.limit.max-resources-mb**The maximum size (in MB) a map reduce job is allowed to submit     for localization via files, libjars, archives, and jobjar command line     arguments and through the distributed cache. If set to 0 the limit is     ignored.   **0
mapreduce.job.cache.limit.max-single-resource-mb**The maximum size (in MB) of a single resource a map reduce job     is allow to submit for localization via files, libjars, archives, and     jobjar command line arguments and through the distributed cache. If set to     0 the limit is ignored.   **0
mapreduce.jobhistory.webapp.xfs-filter.xframe-options**     Value of the xframe-options   **SAMEORIGIN
mapreduce.jobhistory.loadedjob.tasks.max**     The maximum number of tasks that a job can have so that the Job History     Server will fully parse its associated job history file and load it into     memory. A value of -1 (default) will allow all jobs to be loaded.   **-1
mapreduce.job.redacted-properties**     The list of job configuration properties whose value will be redacted.   **N/A
mapreduce.job.send-token-conf**     This configuration is a regex expression. The list of configurations that     match the regex expression will be sent to RM. RM will use these     configurations for renewing tokens.     This configuration is added for below scenario: User needs to run distcp     jobs across two clusters, but the RM does not have necessary hdfs     configurations to connect to the remote hdfs cluster. Hence, user relies on     this config to send the configurations to RM and RM uses these     configurations to renew tokens.     For example the following regex expression indicates the minimum required     configs for RM to connect to a remote hdfs cluster:     dfs.nameservices|^dfs.namenode.rpc-address.*$|^dfs.ha.namenodes.*$|^dfs.client.failover.proxy.provider.*$|dfs.namenode.kerberos.principal   **N/A
